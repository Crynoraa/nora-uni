/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32 VS Code Extension
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stm32l432xx.h>

#define INPUT 'I'
#define OUTPUT 'O'

#define HIGH 1
#define LOW 0

#define MAKE_LIGHT 1
#define MAKE_DARKNESS 0

#define READROM 0x33
#define SKIPROM 0xCC
#define CONVERT_T 0x44
#define READ_SCRATCHPAD 0xbe
char input;

void init_LED(void)
{
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOBEN; // enable clock for peripheral component GPIOB
    (void)RCC->AHB2ENR;                  // ensure that the last write command finished and the clock is on
    // set pin to output mode (1). Reset defaults for other registers are okay here
    GPIOB->MODER = (GPIOB->MODER & ~GPIO_MODER_MODE3_Msk) | (1 << GPIO_MODER_MODE3_Pos);
}

void init_FPU(void)
{
    // enable FPU, needed for printf and your own floating point stuff
    SCB->CPACR |= ((3UL << 10 * 2) | (3UL << 11 * 2)); // Set CP10 and CP11 Full Access
}

void init_UART(void)
{
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOAEN; // enable clock for peripheral component
    (void)RCC->AHB2ENR;                  // ensure that the last write command finished and the clock is on

    // PA2 --> USART2_TX (AF7) see AF table in data sheet
    GPIOA->OTYPER = (GPIOA->OTYPER & ~GPIO_OTYPER_OT2_Msk) | (0 << GPIO_OTYPER_OT2_Pos);   // push-pull
    GPIOA->AFR[0] = (GPIOA->AFR[0] & ~GPIO_AFRL_AFSEL2_Msk) | (7 << GPIO_AFRL_AFSEL2_Pos); // AF 7
    GPIOA->MODER = (GPIOA->MODER & ~GPIO_MODER_MODE2_Msk) | (2 << GPIO_MODER_MODE2_Pos);   // AF

    // PA15 --> USART2_RX (AF3) see AF table in data sheet
    GPIOA->OTYPER = (GPIOA->OTYPER & ~GPIO_OTYPER_OT15_Msk) | (0 << GPIO_OTYPER_OT15_Pos);   // push-pull
    GPIOA->AFR[1] = (GPIOA->AFR[1] & ~GPIO_AFRH_AFSEL15_Msk) | (3 << GPIO_AFRH_AFSEL15_Pos); // AF 3
    GPIOA->MODER = (GPIOA->MODER & ~GPIO_MODER_MODE15_Msk) | (2 << GPIO_MODER_MODE15_Pos);   // AF

    RCC->APB1ENR1 |= RCC_APB1ENR1_USART2EN; // enable clock for peripheral component
    (void)RCC->APB1ENR1;                    // ensure that the last write command finished and the clock is on

    USART2->BRR = 4000000 / 115200;                                              // SYSCLK 4 MHz after reset
    USART2->CR1 = USART_CR1_TE | USART_CR1_RE | USART_CR1_UE | USART_CR1_RXNEIE; // added: enbable RNXE interrupt generation in USART peripheral
    NVIC_EnableIRQ(USART2_IRQn);                                                 // enable USART2 interrupt handling in NVIC
}

void init_Temp(void)
{
    RCC->AHB2ENR |= RCC_AHB2ENR_GPIOBEN; // enable clock for peripheral component GPIOB
    (void)RCC->AHB2ENR;                  // ensure that the last write command finished and the clock is on
    // set pin to output mode (1). Reset defaults for other registers are okay here
    GPIOA->MODER = (GPIOA->MODER & ~GPIO_MODER_MODE5_Msk) | (1 << GPIO_MODER_MODE5_Pos);
}

void set_PA5_mode(char a)
{
    if (a == 'I')
    {
        GPIOA->MODER &= ~(GPIO_MODER_MODE5); // set pin bit to 0
    }
    else if (a == 'O')
    {
        GPIOA->MODER = (GPIOA->MODER & ~GPIO_MODER_MODE5_Msk) | (1 << GPIO_MODER_MODE5_Pos);
    }
    else
    {
    }
}

void set_PA5_out(int num)
{
    if (num == 0)
    {
        GPIOA->ODR &= ~GPIO_ODR_OD5; // set pin to high
    }
    else if (num == 1)
    {
        GPIOA->ODR |= GPIO_ODR_OD5; // set pin to low
    }
    else
    {
    }
}

void set_LED(int b)
{
    if (b == 1)
    {
        GPIOB->ODR |= GPIO_ODR_OD3; // toggles LED
    }
    else if (b == 0)
    {
        GPIOB->ODR &= ~GPIO_ODR_OD3; // toggles LED
    }
    else
    {
    }
}

void usart_putc(uint8_t c)
{
    while (!(USART2->ISR & USART_ISR_TXE))
        ;
    USART2->TDR = c;
    while (!(USART2->ISR & USART_ISR_TC))
        ;
}

void usart_putstr(const char *str)
{

    char c;

    while ((c = *str++))
    {
        usart_putc(c);
    }
}

void USART2_IRQHandler(void)
{
    char c = 0;
    if (USART2->ISR & USART_ISR_RXNE)
    {
        c = (char)USART2->RDR;
        if(c == 'S')
        {
            usart_putc(c);
        }
        else if(c == 'T')
        {
            usart_putc(c);
        }
        else 
        {
            usart_putc(c);
            usart_putstr("\nInvalid command.");
        }
    }
    input = c;
}

void delay(void)
{
    volatile int i = 0;
    while (i < 100000)
    {
        i = i + 1;
    }
}

void delay_us(uint32_t us) // keeps the cpu busy for x microseconds
{
    __asm volatile(
        "mov r0, %[count]\n" // Load the delay count into register r0
        "1:\n"               // Loop label
        "subs r0, r0, #1\n"  // Subtract 1 from r0   (1 CPU cycle)
        "nop\n"              // No operation needed to make the loop body take 4 cycles = 1 Âµs
        "bne 1b\n"           // Branch to loop label if r0 is not zero (2 CPU cycles, measured)
        :
        : [count] "r"(us) // Input: delay_count is the number of iterations
        : "r0"            // Clobbered register
    );
}

void convert_temp(uint16_t bit_temp,char *temp_out) // converts the 16 bit temp received form DS18B20 into a char-array ready to be put out via USART
{
    //I used CHATGPT to help me get an idea how to convert the temperature from uint16_t to a char array

    //convert to signed value of bit
    int16_t temp = (int16_t)bit_temp;

    int16_t frontPart = temp >> 4; // the first 12 bits
    uint8_t backPart = temp & 0x0F; // the last 4 bits
    uint8_t fraction = (backPart * 625) / 100; // multiply with 0.0625

    if (temp < 0)
    {
        temp_out[0] = '-';

        frontPart = -frontPart; // absolute value of it

        temp_out[1] = '0' + (frontPart / 10); // tens-digit
        temp_out[2] = '0' + (frontPart % 10); // One-digit
        temp_out[3] = '.';
    }
    else 
    {
        temp_out[0] = '+';

        temp_out[1] = '0' + (fraction / 10); // tens-digit
        temp_out[2] = '0' + (fraction % 10); // One-digit
        temp_out[3] = '.';
    }
    
    temp_out[4] = '0' + (backPart / 10); // tens-digit
    temp_out[5] = '0' + (backPart % 10); // One-digit
    temp_out[6] = '\0';

}

void write_bit(uint8_t bit)
{
    if (bit == 0)
    {
        set_PA5_out(LOW);
        set_PA5_mode(OUTPUT);
        delay_us(5);
        set_PA5_mode(INPUT);
        delay_us(80);
    }
    else
    {
        set_PA5_out(LOW);
        set_PA5_mode(OUTPUT);
        delay_us(100);
        set_PA5_mode(INPUT);
    }
    delay_us(20);
}


uint8_t read_bit(void)
{
    uint8_t bit = 0;
    set_PA5_out(LOW);
    set_PA5_mode(OUTPUT);
    delay_us(1);
    set_PA5_mode(INPUT);
    delay_us(5);
    if((GPIOA->IDR & GPIO_IDR_ID5) != 0) bit = 1;
    delay_us(55);
    return bit;
}

void write_byte(uint8_t command) // writes a byte long command to the vdd-pin of DSB18B20
{
    set_PA5_mode(OUTPUT);
    for (uint8_t loop = 0; loop < 8; loop++) 
    {
        write_bit(command&0x01);
        command >>= 1;
    }

}

uint8_t read_byte(void) // reads the response from DSB18B20
{
   uint8_t result = 0;
   set_PA5_mode(INPUT);

    for (uint8_t loop = 0; loop < 8; loop++) {
    result >>= 1;

    // if result is one, then set MS bit
    if (read_bit())
    {
      result |= 0x80;
    }
    }
  return result;

}

void presence_check(void) //presence/reset procedure
{
    usart_putstr("\ninitialising presence check");
    set_PA5_mode(OUTPUT);
    set_PA5_out(LOW);

    delay_us(500);

    set_PA5_mode(INPUT);
    delay_us(100);
    if((GPIOA->IDR & GPIO_IDR_ID5) != 0)
    {
        usart_putstr(" presence check unsuccsesful\n");
        return;
    }
    else
    { 
        delay_us(500);
        usart_putstr(" presence check done\n");
        return;
    }
}

void uint_to_string(void *value, int bit_length,char* output)
{
    for (int i = bit_length-1; i >= 0; i--)
    {
        if(*(uint64_t*)value & (1ULL << i))
        {
            output[bit_length-1-i] = '1';
        }
        else 
        {
            output[bit_length-1-i] = '0';
        }
    }
    output[bit_length] = '\0';
    
}

void init(void)
{
    init_FPU();
    init_LED();
    init_UART();
    init_Temp();
}

void get_rom(void)
{   
    
    uint8_t t_b[8];
    uint64_t t_code = 0;
    char rom[65];

    presence_check();
    set_LED(MAKE_DARKNESS);
    write_byte(READROM);

    t_b[0] = read_byte();
    t_b[1] = read_byte();
    t_b[2] = read_byte();
    t_b[3] = read_byte();
    t_b[4] = read_byte();
    t_b[5] = read_byte();
    t_b[6] = read_byte();
    t_b[7] = read_byte();

    t_code = ((uint64_t)t_b[7]<<56)|((uint64_t)t_b[6]<<48)|((uint64_t)t_b[5]<<40)|((uint64_t)t_b[4]<<32)|((uint64_t)t_b[3]<<24)|((uint64_t)t_b[2]<<16)|((uint64_t)t_b[1] <<8)|(uint64_t)t_b[0];

    uint_to_string(&t_code,64,rom);
    usart_putstr("\n...\n");
    usart_putstr("ROM code: ");
    usart_putstr(rom); //ROM-Code in bits
    usart_putstr("\n...\n");
    set_LED(MAKE_LIGHT);
    input = 0;
}

void get_temp(void)
{
    uint8_t t_b[2];
    uint16_t t_temp;
    char char_temp[7];
    char bin_temp[17];

    set_LED(MAKE_DARKNESS);
    presence_check();
    write_byte(SKIPROM);
    write_byte(CONVERT_T);

    delay_us(1000000); //delay for 1s to let temperature conversion finish

    presence_check();
    write_byte(SKIPROM);
    write_byte(READ_SCRATCHPAD);
    // we only require the first 2 bytes since they are the temperature register
    t_b[0] = read_byte();
    t_b[1] = read_byte();
    t_temp = ((uint16_t)t_b[1] << 8) | (uint16_t)t_b[0];
    uint_to_string(&t_temp,16,bin_temp);
    convert_temp(t_temp,char_temp);
    usart_putstr("\n...\n");
    usart_putstr("temp in binary: ");
    usart_putstr(bin_temp); //temp in binary
    usart_putstr("\t");
    usart_putstr("temp in C: ");
    usart_putstr(char_temp); //temp in numbers
    usart_putstr("\n...\n");
    set_LED(MAKE_LIGHT);
    input = 0;
}

int main(void)
{
    init();
    input = 0;
    set_LED(MAKE_LIGHT);
    while (1)
    {
        if (input == 'S')
        {
            get_rom();
        }
        else if (input == 'T')
        {
            get_temp();
        }
        else
        {}
    }
}